---
title: "Pset - Fundamentals of Linear Systems Solutions"
output:
  rmarkdown::md_document:
  header-includes:
   - \usepackage{amsmath}
---

\renewcommand{\vec}[1]{\mathbf{#1}}
\renewcommand{\mat}[1]{\mathbf{#1}}

Load necessary packages:

```{r,message = FALSE}
library("Matrix")
library("igraph")
library("pracma")
```

### Problem 1

A real $n \times n$ matrix $\mat{Q}$ is *orthonormal* if 

$$
\mat{Q}^{T}\,\mat{Q}=\mat{Q}\,\mat{Q}^T=\mat{I};~i.e., \mat{Q}^{-1}=\mat{Q}^T.
$$

Note: sometimes you will see these matrices just called *orthogonal matrices*. 

Show that $||\mat{Q}||_2=||\mat{Q}^{-1}||_2=1$, and therefore the 2-norm condition number of any orthonormal matrix $\mat{Q}$ is $\kappa_2(\mat{Q})=||\mat{Q}||_2 ||\mat{Q}^{-1}||_2=1$.

### Problem 1 Solution

For all $\mat{Q} \in \mathbb{R}^n$, we have

$$
||\mat{Q}\vec{x}||_2^2 = \vec{x}^T \mat{Q}^T \mat{Q} \vec{x} = \vec{x}^T \vec{x} = ||\vec{x}||_2^2,
$$

and therefore $||\mat{Q}\vec{x}||_2=||\vec{x}||_2$. So 

$$
||\mat{Q}||_2 = \max_{\vec{x}~s.t. ||\vec{x}||_2 \neq 0} \frac{||\mat{Q}\vec{x}||_2}{||\vec{x}||_2} = 1.
$$

The same line of reasoning applies to $\mat{Q}^{-1}$, since for all $\mat{Q}$, we have

$$
||\mat{Q}^{-1}\vec{x}||_2^2 = \vec{x}^T (\mat{Q}^{-1})^T \mat{Q}^{-1} \vec{x} = \vec{x}^T \mat{Q} \mat{Q}^{T} \vec{x} = \vec{x}^T \vec{x} = ||\vec{x}||_2^2.
$$

### Problem 2

Consider the $n \times n$ square matrix

$$
A=\begin{pmatrix} 1 & -1 & -1 & -1 & \ldots & -1 \\ 0 & 1 & -1 & -1 & \ldots & -1 \\ 0 & 0 & 1 & -1 & \ldots & -1 \\ \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & 0 & 0 & 0 & 1 \end{pmatrix}.
$$

a\. Write a function that takes a value of $n$ as input and outputs the matrix A above. Challenge yourself to be efficient in your coding when you create the matrix. Looking at patterns and Googling how to create them helps. I managed to create the matrix with no loops, in two lines of code.

b\. Use your function and the R command `kappa` to calculate the approximate condition number $\kappa(\mat{A})$ for $n=1,\ldots,30$. Plot $\log_{10}[\kappa(\mat{A})]$ as a function of $n$ and use the commands `lm` and `abline` to plot a best fit line. How would you describe the conditioning of the matrix as $n$ increases?

c\. Now choose $n=30$. Generate the matrix $\mat{A}$ and let $\vec{b_1}$ be an $n \times 1$ vector of random numbers chosen uniformly from 0 to 1. Solve $\mat{A}\,\vec{x}_1 = \vec{b}_1$ using any appropriate method that you want (including R's built-in capabilities). Now let $\vec{b}_2 = \vec{b}_1 + (0,\ldots,0,0.001)^T$, that is, you leave the first 29 elements the same as in $\vec{b}_1$ but add 0.001 to the last element. Solve $\mat{A}\,\vec{x}_2 = \vec{b}_2$. Use the command `Norm` to find the (approximate)2-norm of $\vec{x_1}-\vec{x_2}$ and discuss vis-a-vis your result from part b. Also, to help build your intuition, find the magnitude of the difference between the first coordinate of $\vec{x}_1$ and that of $\vec{x}_2$.

### Problem 2 Solution

a\. 
```{r}
makeA <- function(n) {
  A <- matrix(-1,n,n)
  A <- A*upper.tri(A) + diag(n)
  return(A)
}
```

b\.
```{r cache = TRUE}
n <- 1:30
cond <- NULL
for (i in n){
  A <- makeA(i)
  cond[i] <- kappa(A,norm="2")
}
plot(n,log10(cond))
model <- lm(log10(cond)~n)
abline(model)
```

The model has a decent linear fit, which means the condition number grows exponentially, and hence the matrix is very poorly conditioned as $n$ grows.

c\.
```{r}
n <- 30
A <- makeA(n)
b <- runif(n)
b1 <- b
x1 <- solve(A,b1)
b2 <- b + c(rep(0,n-1),0.001)
x2 <- solve(A,b2)
Norm(x1-x2)
abs(x1[1] - x2[1])
```
Changing one element of the right hand side by $10^{-3}$ results in a change in the solution that is of order $10^5$, reflecting the poor conditioning of the matrix.

### Problem 3

Note: This problem is taken from Linear Algebra and its Applications, by Lay et al.

<img src="https://github.com/chadtopaz/computationallineaaralgebra/raw/main/psets/heat.png" width="400">

An important concern in the study of heat transfer is to determine the steady-state temperature distribution of a thin plate when the temperature around the boundary is known. Assume the plate shown in the figure above represents a cross section of a metal beam, with negligible heat flow in the direction perpendicular to the plate. Let the variables $x_1, x_2, \ldots, x_8$ denote the temperatures at nodes 1 through 8 in the picture. In steady state, the temperature at a node is approximately equal to the average of the four nearest nodes (to the left, above, right, below).

a\. The solution to the approximate steady-state heat flow problem for this plate can be written as a system of linear equations $\mat{A}\,\vec{x}=\vec{b}$, where $x=[x_1, x_2, \ldots, x_8]$ is the vector of temperatures at nodes 1 through 8. Find the $8 \times 8$ matrix $A$ and the vector $b$.

b\. Solve the system any way you want (using R) to find the unknown temperatures.

### Problem 3 Solution

a\.

$$
A=\begin{pmatrix}
~~4 & -1 & -1 & ~~0 & ~~0 & ~~0 & ~~0 & ~~0 \\
-1 & ~~4 & ~~0 & -1 & ~~0 & ~~0 & ~~0 & ~~0 \\
-1 & ~~0 & ~~4 & -1 & -1 & ~~0 & ~~0 & ~~0 \\
~~0 & -1 & -1 & ~~4 & ~~0 & -1 & ~~0 & ~~0 \\
~~0 & ~~0 & -1 & ~~0 & ~~4 & -1 & -1 & ~~0 \\
~~0 & ~~0 & ~~0 & -1 & -1 & ~~4 & ~~0 & -1 \\
~~0 & ~~0 & ~~0 & ~~0 & -1 & ~~0 & ~~4 & -1 \\
~~0 & ~~0 & ~~0 & ~~0 & ~~0 & -1 & -1 & ~~4 
\end{pmatrix}, \qquad b=\begin{pmatrix} 5 \\ 15 \\0 \\10 \\0 \\10 \\20 \\30 \end{pmatrix}
$$

b\.
```{r cache = TRUE}
A <- matrix(c(4,-1,-1,0,0,0,0,0,
            -1,4,0,-1,0,0,0,0,
            -1,0,4,-1,-1,0,0,0,
            0,-1,-1,4,0,-1,0,0,
            0,0,-1,0,4,-1,-1,0,
            0,0,0,-1,-1,4,0,-1,
            0,0,0,0,-1,0,4,-1,
            0,0,0,0,0,-1,-1,4),
            nrow = 8, byrow = TRUE)
b <- c(5,15,0,10,0,10,20,30)
x <- solve(A,b)
print(x)
```

### Problem 4

The following command loads a matrix $\mat{M}$ describing the western power network of the United States. Each element is zero or one. A one in row $i$ and column $j$ means that component $i$ of the network is connected to component $j$. This type of matrix is called a network's *adjacency matrix*.
```{r cache = TRUE}
M <- as.matrix(readMM(gzcon(url("https://math.nist.gov/pub/MatrixMarket2/Harwell-Boeing/bcspwr/bcspwr10.mtx.gz")))+0)
```
These commands visualize the network for you using a package called `igraph`. It may take a little bit of time (several minutes) to run because the graph is really large!
```{r cache = TRUE, out.width = '70%'}
g <- graph_from_adjacency_matrix(M, mode="undirected")
V(g)$color <- "grey"
V(g)$size <- 2
myLayout <- layout_nicely(g)
plot(simplify(g), layout=myLayout, vertex.color=V(g)$color, vertex.size=V(g)$size, vertex.label="")
```

a\. In the analysis of networks, one is often concerned with finding the most important (most central, in some sense) component. One measure of importance is called Katz centrality. The Katz centrality of the nodes, $\vec{x}$, satisfies

$$
\bigl(\mat{I} - \alpha\,\mat{M}^T)(\vec{x} + \vec{1}) = \vec{1}
$$

where $\mat{I}$ is the identity matrix, $\alpha$ is a small number, and $\vec{1}$ is a vector of all ones. Take $\alpha = 0.05$ and solve for $\vec{x}$ using any method you want. Print out the largest element of $\vec{x}$ so that I can verify your answer.

b\. Re-plot the network using your same graph layout as before, color the most important node red and plot it with size 5. This way, the most important node (at least, according to the Katz measure) will stand out on your plot.

### Problem 4 Solution

a\. 
```{r cache = TRUE}
n <- dim(M)[1]
A <- diag(n) - 0.001*t(M) 
ones <- rep(1,n)
x <- solve(A, ones) - ones
paste0("Maximum value of x is ",round(max(x),digits=8))
```

b\.
```{r cache = TRUE, out.width = '70%'}
impt <- which(x==max(x))
V(g)$color[impt] <- "red"
V(g)$size[impt] <- 5
plot(simplify(g),layout=myLayout,vertex.label="")
```